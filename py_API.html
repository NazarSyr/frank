



<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Frankenstein Python API &mdash; frank 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Index" href="genindex.html" />
    <link rel="prev" title="Examining the model’s limitations" href="tutorials/model_limitations.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> frank
          

          
            
            <img src="_static/prom_photo.jpg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Using the code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html"> Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html"> Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html"> Tutorials</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ui.adsabs.harvard.edu/search/q=citations(doi%3A10.1093%2Fmnras%2Fstaa1365)%20&amp;sort=date%20desc%2C%20bibcode%20desc&amp;p_=0"> Papers using frank</a></li>
</ul>
<p class="caption"><span class="caption-text">Under the hood</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#"> API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#geometry-classes">Geometry classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fitting-classes">Fitting classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#utility-functions-and-classes">Utility functions and classes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html"> Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/discsim/frank"> Github</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/discsim/frank/issues"> Submit an issue</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">frank</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>The Frankenstein Python API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="the-frankenstein-python-api">
<h1>The Frankenstein Python API<a class="headerlink" href="#the-frankenstein-python-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="geometry-classes">
<h2>Geometry classes<a class="headerlink" href="#geometry-classes" title="Permalink to this headline">¶</a></h2>
<p>Given a set of visibilities, together these classes: <strong>(1)</strong> optionally fit for the source geometry and
<strong>(2)</strong> deproject the visibilities by the given or fitted geometry.</p>
<dl class="py class">
<dt id="frank.geometry.FixedGeometry">
<em class="property">class </em><code class="sig-prename descclassname">frank.geometry.</code><code class="sig-name descname">FixedGeometry</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inc</span></em>, <em class="sig-param"><span class="n">PA</span></em>, <em class="sig-param"><span class="n">dRA</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">dDec</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.FixedGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Disc Geometry class using pre-determined parameters.</p>
<p>Centre and deproject the source to ensure axisymmetry</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inc</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Disc inclination</p></li>
<li><p><strong>PA</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Disc positition angle.</p></li>
<li><p><strong>dRA</strong> (<em>float</em><em>, </em><em>default = 0</em><em>, </em><em>unit = arcsec</em>) – Phase centre offset in right ascension</p></li>
<li><p><strong>dDec</strong> (<em>float</em><em>, </em><em>default = 0</em><em>, </em><em>unit = arcsec</em>) – Phase centre offset in declination</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The phase centre offsets, dRA and dDec, refer to the distance to the source
from the phase centre.</p>
</dd></dl>

<dl class="py class">
<dt id="frank.geometry.FitGeometryGaussian">
<em class="property">class </em><code class="sig-prename descclassname">frank.geometry.</code><code class="sig-name descname">FitGeometryGaussian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phase_centre</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">guess</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.FitGeometryGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the disc geometry by fitting a Gaussian in Fourier space.</p>
<p>Centre and deproject the source to ensure axisymmetry</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phase_centre</strong> (<em>tuple =</em><em> (</em><em>dRA</em><em>, </em><em>dDec</em><em>) or </em><em>None</em><em> (</em><em>default</em><em>)</em><em>, </em><em>unit = arcsec</em>) – Determine whether to fit for the source’s phase centre. If
phase_centre = None, the phase centre is fit for. Else the phase
centre should be provided as a tuple</p></li>
<li><p><strong>guess</strong> (<em>list of len</em><em>(</em><em>4</em><em>)</em><em>, </em><em>default = None</em>) – Initial guess for the source’s inclination [deg], position angle [deg],
right ascension offset [arcsec], declination offset [arcsec].</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The phase centre offsets, dRA and dDec, refer to the distance to the source
from the phase centre.</p>
</dd></dl>

<dl class="py class">
<dt id="frank.geometry.FitGeometryFourierBessel">
<em class="property">class </em><code class="sig-prename descclassname">frank.geometry.</code><code class="sig-name descname">FitGeometryFourierBessel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Rmax</span></em>, <em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">phase_centre</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">guess</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.FitGeometryFourierBessel" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the disc geometry by fitting a non-parametric brightness
profile in visibility space.</p>
<p>The best fit is obtained by finding the geometry that minimizes
the weighted chi^2 of the visibility fit.</p>
<p>The brightness profile is modelled using the FourierBesselFitter,
which is equivalent to a FrankFitter fit without the Gaussian
Process prior. For this reason, a small number of bins is
recommended for fit stability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Rmax</strong> (<em>float</em><em>, </em><em>unit = arcsec</em>) – <dl class="simple">
<dt>Radius of support for the functions to transform, i.e.,</dt><dd><p>f(r) = 0 for R &gt;= Rmax</p>
</dd>
</dl>
</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Number of collocation points</p></li>
<li><p><strong>phase_centre</strong> (<em>tuple =</em><em> (</em><em>dRA</em><em>, </em><em>dDec</em><em>) or </em><em>None</em><em> (</em><em>default</em><em>)</em><em>, </em><em>unit = arcsec</em>) – Determine whether to fit for the source’s phase centre. If
phase_centre = None, the phase centre is fit for. Else the phase
centre should be provided as a tuple</p></li>
<li><p><strong>guess</strong> (<em>list of len</em><em>(</em><em>4</em><em>)</em><em>, </em><em>default = None</em>) – Initial guess for the source’s inclination [deg], position angle [deg],
right ascension offset [arcsec], and declination offset [arcsec]</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Determines whether to print the iteration progress.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="frank.geometry.SourceGeometry">
<em class="property">class </em><code class="sig-prename descclassname">frank.geometry.</code><code class="sig-name descname">SourceGeometry</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">PA</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dRA</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dDec</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for geometry corrections.</p>
<p>Centre and deproject the source to ensure axisymmetry</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inc</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Inclination of the disc</p></li>
<li><p><strong>PA</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Position angle of the disc</p></li>
<li><p><strong>dRA</strong> (<em>float</em><em>, </em><em>unit = arcsec</em>) – Phase centre offset in right ascension.</p></li>
<li><p><strong>dDec</strong> (<em>float</em><em>, </em><em>units = arcsec</em>) – Phase centre offset in declination.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The phase centre offsets, dRA and dDec, refer to the distance to the source
from the phase centre.</p>
<dl class="py method">
<dt id="frank.geometry.SourceGeometry.apply_correction">
<code class="sig-name descname">apply_correction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">V</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.apply_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct the phase centre and deproject the visibilities</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u-points of the visibilities</p></li>
<li><p><strong>v</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – v-points of the visibilities</p></li>
<li><p><strong>V</strong> (<em>array of real</em><em>, </em><em>size = N</em><em>, </em><em>units = Jy</em>) – Complex visibilites</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>up</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected u-points of the visibilities</p></li>
<li><p><strong>vp</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected v-points of the visibilities</p></li>
<li><p><strong>Vp</strong> (<em>array of real, size = N, unit = Jy</em>) – Corrected complex visibilites</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="frank.geometry.SourceGeometry.deproject">
<code class="sig-name descname">deproject</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.deproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert uv-points from sky-plane to deprojected space</p>
</dd></dl>

<dl class="py method">
<dt id="frank.geometry.SourceGeometry.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">V</span></em>, <em class="sig-param"><span class="n">weights</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine geometry using the provided uv-data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u-points of the visibilities</p></li>
<li><p><strong>v</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – v-points of the visibilities</p></li>
<li><p><strong>V</strong> (<em>array of complex</em><em>, </em><em>size = N</em><em>, </em><em>unit = Jy</em>) – Complex visibilites</p></li>
<li><p><strong>weights</strong> (<em>array of real</em><em>, </em><em>size = N</em><em>, </em><em>unit = Jy</em>) – Weights on the visibilities</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="frank.geometry.SourceGeometry.reproject">
<code class="sig-name descname">reproject</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.reproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert uv-points from deprojected space to sky-plane</p>
</dd></dl>

<dl class="py method">
<dt id="frank.geometry.SourceGeometry.undo_correction">
<code class="sig-name descname">undo_correction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">V</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.undo_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo the phase centre correction and deprojection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u-points of the visibilities</p></li>
<li><p><strong>v</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – v-points of the visibilities</p></li>
<li><p><strong>V</strong> (<em>array of real</em><em>, </em><em>size = N</em><em>, </em><em>unit = Jy</em>) – Complex visibilites</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>up</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected u-points of the visibilities</p></li>
<li><p><strong>vp</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected v-points of the visibilities</p></li>
<li><p><strong>Vp</strong> (<em>array of real, size = N, unit = Jy</em>) – Corrected complex visibilites</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="fitting-classes">
<h2>Fitting classes<a class="headerlink" href="#fitting-classes" title="Permalink to this headline">¶</a></h2>
<p>Together these classes reconstruct the 1D radial brightness profile of a source by fitting
the deprojected visibilities.</p>
<dl class="py class">
<dt id="frank.radial_fitters.FrankFitter">
<em class="property">class </em><code class="sig-prename descclassname">frank.radial_fitters.</code><code class="sig-name descname">FrankFitter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Rmax</span></em>, <em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">geometry</span></em>, <em class="sig-param"><span class="n">nu</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">block_data</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">block_size</span><span class="o">=</span><span class="default_value">100000</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">1.05</span></em>, <em class="sig-param"><span class="n">p_0</span><span class="o">=</span><span class="default_value">1e-15</span></em>, <em class="sig-param"><span class="n">weights_smooth</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">2000</span></em>, <em class="sig-param"><span class="n">check_qbounds</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">store_iteration_diagnostics</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a Gaussian process model using the Discrete Hankel Transform of
Baddour &amp; Chouinard (2015).</p>
<p>The GP model is based upon Oppermann et al. (2013), which use a maximum
a posteriori estimate for the power spectrum as the GP prior for the
real-space coefficients</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Rmax</strong> (<em>float</em><em>, </em><em>unit = arcsec</em>) – Radius of support for the functions to transform, i.e., f(r) = 0 for
R &gt;= Rmax.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Number of collaction points</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em>) – Geometry used to deproject the visibilities before fitting</p></li>
<li><p><strong>nu</strong> (<em>int</em><em>, </em><em>default = 0</em>) – Order of the discrete Hankel transform, given by J_nu(r)</p></li>
<li><p><strong>block_data</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Large temporary matrices are needed to set up the data. If block_data
is True, we avoid this, limiting the memory requirement to block_size
elements</p></li>
<li><p><strong>block_size</strong> (<em>int</em><em>, </em><em>default = 10**5</em>) – Size of the matrices if blocking is used</p></li>
<li><p><strong>alpha</strong> (<em>float &gt;= 1</em><em>, </em><em>default = 1.05</em>) – Order parameter of the inverse gamma prior for the power spectrum
coefficients</p></li>
<li><p><strong>p_0</strong> (<em>float &gt;= 0</em><em>, </em><em>default = 1e-15</em><em>, </em><em>unit=Jy^2</em>) – Scale parameter of the inverse gamma prior for the power spectrum
coefficients</p></li>
<li><p><strong>weights_smooth</strong> (<em>float &gt;= 0</em><em>, </em><em>default = 1e-4</em>) – Spectral smoothness prior parameter. Zero is no smoothness prior</p></li>
<li><p><strong>tol</strong> (<em>float &gt; 0</em><em>, </em><em>default = 1e-3</em>) – Tolerence for convergence of the power spectrum iteration</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>default = 2000</em>) – Maximum number of fit iterations</p></li>
<li><p><strong>check_qbounds</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Whether to check if the first (last) collocation point is smaller
(larger) than the shortest (longest) deprojected baseline in the dataset</p></li>
<li><p><strong>store_iteration_diagnostics</strong> (<em>bool</em><em>, </em><em>default = False</em>) – Whether to store the power spectrum parameters and brightness profile
for each fit iteration</p></li>
<li><p><strong>verbose</strong> – Whether to print notification messages</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>Baddour &amp; Chouinard (2015)</dt><dd><p>DOI: <a class="reference external" href="https://doi.org/10.1364/JOSAA.32.000611">https://doi.org/10.1364/JOSAA.32.000611</a></p>
</dd>
<dt>Oppermann et al. (2013)</dt><dd><p>DOI:  <a class="reference external" href="https://doi.org/10.1103/PhysRevE.87.032136">https://doi.org/10.1103/PhysRevE.87.032136</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.MAP_solution">
<em class="property">property </em><code class="sig-name descname">MAP_solution</code><a class="headerlink" href="#frank.radial_fitters.FrankFitter.MAP_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruction for the maximum a posteriori power spectrum</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.MAP_spectrum">
<em class="property">property </em><code class="sig-name descname">MAP_spectrum</code><a class="headerlink" href="#frank.radial_fitters.FrankFitter.MAP_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum a posteriori power spectrum</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.MAP_spectrum_covariance">
<em class="property">property </em><code class="sig-name descname">MAP_spectrum_covariance</code><a class="headerlink" href="#frank.radial_fitters.FrankFitter.MAP_spectrum_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Covariance matrix of the maximum a posteriori power spectrum</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.Qmax">
<em class="property">property </em><code class="sig-name descname">Qmax</code><a class="headerlink" href="#frank.radial_fitters.FrankFitter.Qmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum frequency, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.Rmax">
<em class="property">property </em><code class="sig-name descname">Rmax</code><a class="headerlink" href="#frank.radial_fitters.FrankFitter.Rmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum radius, unit = arcsec</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">V</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the visibilties</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong><strong>,</strong><strong>v</strong> (1D array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points of the visibilies</p></li>
<li><p><strong>V</strong> (<em>1D array</em><em>, </em><em>unit = Jy</em>) – Visibility amplitudes at q</p></li>
<li><p><strong>weights</strong> (<em>1D array</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy^-2</em>) – Weights of the visibilities, weight = 1 / sigma^2, where sigma is
the standard deviation</p></li>
<li><p><strong>iteration_diagnostics</strong> (<em>dict</em><em>, </em><em>optional</em><em>,</em>) – size = N_iter x 2 x N_{collocation points}
Power spectrum parameters and posterior mean brightness profile at
each fit iteration, and number of iterations</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>MAP_solution</strong> – Reconstructed profile using maximum a posteriori power spectrum</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#frank.radial_fitters._HankelRegressor" title="frank.radial_fitters._HankelRegressor">_HankelRegressor</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.geometry">
<em class="property">property </em><code class="sig-name descname">geometry</code><a class="headerlink" href="#frank.radial_fitters.FrankFitter.geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Geometry object</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.q">
<em class="property">property </em><code class="sig-name descname">q</code><a class="headerlink" href="#frank.radial_fitters.FrankFitter.q" title="Permalink to this definition">¶</a></dt>
<dd><p>Frequency points, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.r">
<em class="property">property </em><code class="sig-name descname">r</code><a class="headerlink" href="#frank.radial_fitters.FrankFitter.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Radius points, unit = arcsec</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters.FrankFitter.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#frank.radial_fitters.FrankFitter.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of points in reconstruction</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="frank.radial_fitters._HankelRegressor">
<em class="property">class </em><code class="sig-prename descclassname">frank.radial_fitters.</code><code class="sig-name descname">_HankelRegressor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">DHT</span></em>, <em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">geometry</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">noise_likelihood</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters._HankelRegressor" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the linear regression problem to compute the posterior,</p>
<div class="math notranslate nohighlight">
\[P(I|q,V,p) \propto G(I-\mu, D),\]</div>
<p>where <span class="math notranslate nohighlight">\(I\)</span> is the intensity to be predicted, <span class="math notranslate nohighlight">\(q\)</span> are the
baselines and <span class="math notranslate nohighlight">\(V\)</span> the visibility data. <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(D\)</span> are
the mean and covariance of the posterior distribution.</p>
<p>If <span class="math notranslate nohighlight">\(p\)</span> is provided, the covariance matrix of the prior is included,
with</p>
<div class="math notranslate nohighlight">
\[P(I|p) \propto G(I, S(p)),\]</div>
<p>and the Bayesian Linear Regression problem is solved. <span class="math notranslate nohighlight">\(S\)</span> is computed
from the power spectrum, <span class="math notranslate nohighlight">\(p\)</span>, if provided. Otherwise the traditional
(frequentist) linear regression is used.</p>
<p>The problem is framed in terms of the design matrix <span class="math notranslate nohighlight">\(M\)</span> and
information source <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p><span class="math notranslate nohighlight">\(H(q)\)</span> is the matrix that projects the intensity <span class="math notranslate nohighlight">\(I\)</span> to
visibility space. <span class="math notranslate nohighlight">\(M\)</span> is defined by</p>
<div class="math notranslate nohighlight">
\[M = H(q)^T w H(q),\]</div>
<p>where <span class="math notranslate nohighlight">\(w\)</span> is the weights matrix and</p>
<div class="math notranslate nohighlight">
\[j = H(q)^T w V.\]</div>
<p>The mean and covariance of the posterior are then given by</p>
<div class="math notranslate nohighlight">
\[\mu = D j\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[D = [ M + S(p)^{-1}]^{-1},\]</div>
<p>if the prior is provided, otherwise</p>
<div class="math notranslate nohighlight">
\[D = M^{-1}.\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>DHT</strong> (<em>DiscreteHankelTransform</em>) – A DHT object with N bins that defines H(p). The DHT is used to compute
<span class="math notranslate nohighlight">\(S(p)\)</span></p></li>
<li><p><strong>M</strong> (<em>2D array</em><em>, </em><em>size =</em><em> (</em><em>N</em><em>, </em><em>N</em><em>)</em>) – The design matrix, see above</p></li>
<li><p><strong>j</strong> (<em>1D array</em><em>, </em><em>size = N</em>) – Information source, see above</p></li>
<li><p><strong>p</strong> (<em>1D array</em><em>, </em><em>size = N</em><em>, </em><em>optional</em>) – Power spectrum used to generate the covarience matrix <span class="math notranslate nohighlight">\(S(p)\)</span></p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – If provided, this geometry will be used to deproject the visibilities
in self.predict</p></li>
<li><p><strong>noise_likelihood</strong> (<em>float</em><em>, </em><em>optional</em>) – <p>An optional parameter needed to compute the full likelihood, which
should be equal to</p>
<div class="math notranslate nohighlight">
\[-\frac{1}{2} V^T w V + \frac{1}{2} \sum \log[w/(2 \pi)].\]</div>
<p>If not  provided, the likelihood can still be computed up to this
missing constant</p>
</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.Qmax">
<em class="property">property </em><code class="sig-name descname">Qmax</code><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.Qmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum frequency, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.Rmax">
<em class="property">property </em><code class="sig-name descname">Rmax</code><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.Rmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum radius, unit = arcsec</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.covariance">
<em class="property">property </em><code class="sig-name descname">covariance</code><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Posterior covariance, unit = (Jy / sr)**2</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.geometry">
<em class="property">property </em><code class="sig-name descname">geometry</code><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Geometry object</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.log_likelihood">
<code class="sig-name descname">log_likelihood</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">I</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.log_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute one of two types of likelihood.</p>
<p>If <span class="math notranslate nohighlight">\(I\)</span> is provided, this computes</p>
<p>Otherwise the marginalized likelihood is computed,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>I</strong> (<em>array</em><em>, </em><em>size = N</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy / sr</em>) – Intensity <span class="math notranslate nohighlight">\(I(r)\)</span> to compute the likelihood of</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>log_P</strong> – Log likelihood, <span class="math notranslate nohighlight">\(\log[P(I,V|p)]\)</span> or <span class="math notranslate nohighlight">\(\log[P(V|p)]\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>The prior probability P(S) is not included.</p></li>
<li><p>The likelihoods take the form:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\log[P(I,V|p)] = \frac{1}{2} j^T I - \frac{1}{2} I^T D^{-1} I
   - \frac{1}{2} \log[\det(2 \pi S)] + H_0\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\log[P(V|p)] = \frac{1}{2} j^T D j
   + \frac{1}{2} \log[\det(D)/\det(S)] + H_0\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[H_0 = -\frac{1}{2} V^T w V + \frac{1}{2} \sum \log(w /2 \pi)\]</div>
<p>is the noise likelihood.</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.mean">
<em class="property">property </em><code class="sig-name descname">mean</code><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Posterior mean, unit = Jy / sr</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.power_spectrum">
<em class="property">property </em><code class="sig-name descname">power_spectrum</code><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.power_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Power spectrum coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">I</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">geometry</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">block_size</span><span class="o">=</span><span class="default_value">100000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the visibilities in the sky-plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>u</em><em>,</em>) – uv-points to predict the visibilities at</p></li>
<li><p><strong>I</strong> (<em>array</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy</em>) – Intensity points to predict the vibilities of. If not specified,
the mean will be used. The intensity should be specified at the
collocation points, I[k] = <span class="math notranslate nohighlight">\(I(r_k)\)</span></p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used</p></li>
<li><p><strong>block_size</strong> (<em>int</em><em>, </em><em>default = 10**5</em>) – Maximum matrix size used in the visibility calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>V(u,v)</strong> – Predicted visibilties of a source with a radial flux distribution
given by <span class="math notranslate nohighlight">\(I\)</span> and the position angle, inclination and phase
centre determined by the geometry object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, unit = Jy</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.predict_deprojected">
<code class="sig-name descname">predict_deprojected</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">I</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">geometry</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">block_size</span><span class="o">=</span><span class="default_value">100000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.predict_deprojected" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the visibilities in the deprojected-plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (array, default = self.q, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – 1D uv-points to predict the visibilities at</p></li>
<li><p><strong>I</strong> (<em>array</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy / sr</em>) – Intensity points to predict the vibilities of. If not specified,
the mean will be used. The intensity should be specified at the
collocation points, I[k] = I(r_k)</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used</p></li>
<li><p><strong>block_size</strong> (<em>int</em><em>, </em><em>default = 10**5</em>) – Maximum matrix size used in the visibility calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>V(q)</strong> – Predicted visibilties of a source with a radial flux distribution
given by <span class="math notranslate nohighlight">\(I\)</span>. The amplitude of the visibilities are reduced
according to the inclination of the source, for consistency with
<code class="code docutils literal notranslate"><span class="pre">uvplot</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, unit = Jy</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The visibility amplitudes are still reduced due to the projection,
for consistentcy with <code class="code docutils literal notranslate"><span class="pre">uvplot</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.q">
<em class="property">property </em><code class="sig-name descname">q</code><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.q" title="Permalink to this definition">¶</a></dt>
<dd><p>Frequency points, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.r">
<em class="property">property </em><code class="sig-name descname">r</code><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Radius points, unit = arcsec</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of points in reconstruction</p>
</dd></dl>

<dl class="py method">
<dt id="frank.radial_fitters._HankelRegressor.solve_non_negative">
<code class="sig-name descname">solve_non_negative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters._HankelRegressor.solve_non_negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the best fit solution with non-negative intensities</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="utility-functions-and-classes">
<h2>Utility functions and classes<a class="headerlink" href="#utility-functions-and-classes" title="Permalink to this headline">¶</a></h2>
<p>These are some useful functions and classes for various aspects of fitting and analysis.</p>
<dl class="py function">
<dt id="frank.utilities.arcsec_baseline">
<code class="sig-prename descclassname">frank.utilities.</code><code class="sig-name descname">arcsec_baseline</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.arcsec_baseline" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide x as a radial scale [arcsec] to return the corresponding baseline
[lambda], or vice-versa</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>float</em>) – Radial scale [arcsec] or baseline [lambda]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>converted</strong> – Baseline [lambda] or radial scale [arcsec]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="frank.utilities.convolve_profile">
<code class="sig-prename descclassname">frank.utilities.</code><code class="sig-name descname">convolve_profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">I</span></em>, <em class="sig-param"><span class="n">disc_i</span></em>, <em class="sig-param"><span class="n">disc_pa</span></em>, <em class="sig-param"><span class="n">clean_beam</span></em>, <em class="sig-param"><span class="n">n_per_sigma</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.convolve_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve a 1D radial brightness profile with a 2D Gaussian beam, degrading
the profile’s resolution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>array</em>) – Radial coordinates at which the 1D brightness profile is defined</p></li>
<li><p><strong>I</strong> (<em>array</em>) – Brightness values at r</p></li>
<li><p><strong>disc_i</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Disc inclination</p></li>
<li><p><strong>disc_pa</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Disc position angle</p></li>
<li><p><strong>clean_beam</strong> (<em>dict</em>) – Dictionary with beam <code class="code docutils literal notranslate"><span class="pre">bmaj</span></code> (FWHM of beam along its major axis) [arcsec],
<code class="code docutils literal notranslate"><span class="pre">bmin</span></code> (FWHM of beam along its minor axis) [arcsec],
<code class="code docutils literal notranslate"><span class="pre">pa</span></code> (beam position angle) [deg]</p></li>
<li><p><strong>n_per_sigma</strong> (<em>int</em><em>, </em><em>default = 5</em>) – Number of points per standard deviation of the Gaussian kernel (used
for gridding)</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>default = 0</em>) – Axis over which to interpolate the 1D profile</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>I_smooth</strong> – Convolved brightness profile I at coordinates r</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = (len(r), len(r))</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="frank.utilities.cut_data_by_baseline">
<code class="sig-prename descclassname">frank.utilities.</code><code class="sig-name descname">cut_data_by_baseline</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">vis</span></em>, <em class="sig-param"><span class="n">weights</span></em>, <em class="sig-param"><span class="n">cut_range</span></em>, <em class="sig-param"><span class="n">geometry</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.cut_data_by_baseline" title="Permalink to this definition">¶</a></dt>
<dd><p>Truncate the data to be within a chosen baseline range.</p>
<p>The cut will be done in deprojected baseline space if the geometry is
provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>u</em><em>,</em>) – u and v coordinates of observations</p></li>
<li><p><strong>vis</strong> (<em>array</em><em>, </em><em>unit = Jy</em>) – Observed visibilities (complex: real + imag * 1j)</p></li>
<li><p><strong>weights</strong> (<em>array</em><em>, </em><em>unit = Jy^-2</em>) – Weights assigned to observed visibilities, of the form
<span class="math notranslate nohighlight">\(1 / \sigma^2\)</span></p></li>
<li><p><strong>cut_range</strong> (<em>list of float</em><em>, </em><em>length = 2</em><em>, </em><em>unit =</em><em> [</em><em>lambda</em><em>]</em>) – Lower and upper baseline bounds outside of which visibilities are
truncated</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Fitted geometry (see frank.geometry.SourceGeometry).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>u_cut, v_cut</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates in the chosen baseline range</p></li>
<li><p><strong>vis_cut</strong> (<em>array, unit = Jy</em>) – Visibilities in the chosen baseline range</p></li>
<li><p><strong>weights_cut</strong> (<em>array, unit = Jy^-2</em>) – Weights in the chosen baseline range</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="frank.utilities.draw_bootstrap_sample">
<code class="sig-prename descclassname">frank.utilities.</code><code class="sig-name descname">draw_bootstrap_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">vis</span></em>, <em class="sig-param"><span class="n">weights</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.draw_bootstrap_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the sample for a bootstrap, drawing, with replacement, N samples from
a length N dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>u</em><em>,</em>) – u and v coordinates of observations</p></li>
<li><p><strong>vis</strong> (<em>array</em><em>, </em><em>unit = Jy</em>) – Observed visibilities (complex: real + imag * 1j)</p></li>
<li><p><strong>weights</strong> (<em>array</em><em>, </em><em>unit = Jy^-2</em>) – Weights on the visibilities, of the form
<span class="math notranslate nohighlight">\(1 / \sigma^2\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>u_boot, v_boot</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Bootstrap sampled u and v coordinates</p></li>
<li><p><strong>vis_boot</strong> (<em>array, unit = Jy</em>) – Bootstrap sampled visibilities</p></li>
<li><p><strong>weights_boot</strong> (<em>array, unit = Jy^-2</em>) – Boostrap sampled weights on the visibilities</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="frank.utilities.estimate_weights">
<code class="sig-prename descclassname">frank.utilities.</code><code class="sig-name descname">estimate_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">V</span></em>, <em class="sig-param"><span class="n">nbins</span><span class="o">=</span><span class="default_value">300</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">use_median</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.estimate_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the weights using the variance of the binned visibilities.</p>
<p>The estimation is done assuming that the variation in each bin is dominated
by the noise. This will be true if:
1) The source is axi-symmetric,
2) The uv-points have been deprojected,
3) The bins are not too wide,
Otherwise the variance may be dominated by intrinsic variations in the
visibilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>u</em><em>,</em>) – u and v coordinates of observations (deprojected).</p></li>
<li><p><strong>V</strong> (<em>array</em><em>, </em><em>unit = Jy</em>) – Observed visibility. If complex, the weights will be computed from the
average of the variance of the real and imaginary components, as in
CASA’s statwt. Otherwise the variance of the real part is used.</p></li>
<li><p><strong>nbins</strong> (<em>int</em><em>, </em><em>default = 300</em>) – Number of bins used.</p></li>
<li><p><strong>log</strong> (<em>bool</em><em>, </em><em>default = True</em>) – If True, the uv bins will be constructed in log space, otherwise linear
spaced bins will be used.</p></li>
<li><p><strong>use_median</strong> (<em>bool</em><em>, </em><em>default = False</em>) – If True all of the weights will be set to the median of the variance
estimated across the bins. Otherwise, the baseline dependent variance
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>weights</strong> – Estimate of the weight for each uv point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function does not use the original weights in the estimation.</p></li>
<li><p>Bins with only one uv point do not have a variance estimate. Thus
the mean of the variance in the two adjacent bins is used instead.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt id="frank.utilities.normalize_uv">
<code class="sig-prename descclassname">frank.utilities.</code><code class="sig-name descname">normalize_uv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">wle</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.normalize_uv" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize data u and v coordinates by the observing wavelength</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>u</em><em>,</em>) – u and v coordinates of observations</p></li>
<li><p><strong>wle</strong> (<em>float</em><em>, </em><em>unit =</em><em> [</em><em>m</em><em>]</em>) – Observing wavelength of observations</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>u_normed, v_normed</strong> – u and v coordinates normalized by observing wavelength</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="frank.utilities.sweep_profile">
<code class="sig-prename descclassname">frank.utilities.</code><code class="sig-name descname">sweep_profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">I</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.sweep_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Sweep a 1D radial brightness profile over <span class="math notranslate nohighlight">\(2 \pi\)</span> to yield a 2D
brightness distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>array</em>) – Radial coordinates at which the 1D brightness profile is defined</p></li>
<li><p><strong>I</strong> (<em>array</em>) – Brightness values at r</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>default = 0</em>) – Axis over which to interpolate the 1D profile</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>I2D</strong> (<em>array, shape = (len(r), len(r))</em>) – 2D brightness distribution</p></li>
<li><p><strong>xmax</strong> (<em>float</em>) – Maximum x-value of the 2D grid</p></li>
<li><p><strong>ymax</strong> (<em>float</em>) – Maximum y-value of the 2D grid</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="frank.utilities.UVDataBinner">
<em class="property">class </em><code class="sig-prename descclassname">frank.utilities.</code><code class="sig-name descname">UVDataBinner</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">uv</span></em>, <em class="sig-param"><span class="n">V</span></em>, <em class="sig-param"><span class="n">weights</span></em>, <em class="sig-param"><span class="n">bin_width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.UVDataBinner" title="Permalink to this definition">¶</a></dt>
<dd><p>Average uv-data into bins of equal size.</p>
<p>Compute the weighted mean of the visibilities in each bin</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uv</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Baselines of the data to bin</p></li>
<li><p><strong>V</strong> (<em>array</em><em>, </em><em>unit = Jy</em>) – Complex visibilities</p></li>
<li><p><strong>weights</strong> (<em>array</em><em>, </em><em>unit = Jy^-2</em>) – Weights on the visibility points</p></li>
<li><p><strong>bin_width</strong> (float, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Width of the uv-bins</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses numpy masked arrays to mask bins with no uv points.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="genindex.html" class="btn btn-neutral float-right" title="Index" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tutorials/model_limitations.html" class="btn btn-neutral float-left" title="Examining the model’s limitations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019-2020, R. Booth, J. Jennings, M. Tazzari (docs by J. Jennings).
      <span class="lastupdated">
        Last updated on 2020 May 20 at 16:09:01 UTC // Images: Universal Studios, NBCUniversal [Public domain].
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>